<link rel="import" href="google-analytics-base.html">
<link rel="import" href="../google-chart/google-chart.html">
<link rel="import" href="../native-promise-only/">

<polymer-element
  name="google-analytics-datachart"
  extends="google-analytics-query"
  attributes="
    type
    width
    height">

  <template>
    <style>
      google-chart {
        background: #fff;
        border: 1px solid #ccc;
        display: inline-block;
        margin: 1em;
        padding: 1.5em;
      }
    </style>

    <google-chart id="chart"
      type="{{type}}"
      width="{{width}}"
      height="{{height}}"
      type="{{type}}"
      data="{{data.dataTable}}">
    </google-chart>

  </template>

  <script>

    (function() {

      var metadata;

      Polymer('google-analytics-datachart', {

        type: 'area',

        width: 400,

        height: 300,

        output: 'dataTable',

        data: null,

        ready: function() {
          this.$.chart.options = getChartOptionsByType(this.type);
        },

        analyticsAuthorize: function() {
          this.super();

          // Start this as soon as possible so we don't have to wait later.
          getMetadata();
        },

        handleResponse: function(response) {
          if (response.error) {
            this.fire('analytics-query-error', response.error);
          }
          else {
            getMetadata().then(function(metadata) {
              response.dataTable.cols.forEach(function(col) {
                col.label = metadata[col.id] || col.label;
              });
              this.data = response;
              this.fire('analytics-query-success', response);
            }.bind(this));
          }
        }
      });

      var getMetadata = (function() {
        var promise;

        function queryMetadataAPI() {
          return new Promise(function(resolve, reject) {
            gapi.client.analytics.metadata.columns
                .list({reportType:'ga'})
                .execute(function(response) {
                  if (response.error) {
                    reject(response.error);
                  }
                  else {
                    var metadata = {};
                    response.items.forEach(function(item) {
                      metadata[item.id] = item.attributes.uiName;
                    })
                    resolve(metadata);
                  }
                });
          });
        }
        return function() {
          return promise || (promise = queryMetadataAPI());
        };
      }());


      function getChartOptionsByType(type) {
        var chartOptions = {
          base: {
            fontSize: 11,
            chartArea: {
              width: '100%'
            },
            legend: {
              position: 'top',
              alignment: 'start'
            },
            titleTextStyle: {
              fontName: 'Arial',
              fontSize: 16,
              bold: false
            }
          },
          area: {
            pointSize: 6,
            lineWidth: 4,
            areaOpacity: 0.1,
            colors: ['#058dc7', '#aadff3'],
            hAxis: {
              format: 'MMM d',
              gridlines: {
                color: 'transparent'
              },
              baselineColor: 'transparent'
            },
            vAxis: {
              gridlines: {
                color: '#e8e8e8',
                logScale: true,
                count: 3
              },
              textPosition: 'in'
            }
          },
          bar: {
            colors: ['#058dc7', '#50b432', '#ed561b'],
            hAxis: {
              gridlines: {
                color: '#e8e8e8'
              }
            },
            vAxis: {
              textPosition: 'in'
            }
          },
          column: {
            colors: ['#058dc7', '#50b432', '#ed561b'],
            vAxis: {
              gridlines: {
                color: '#e8e8e8',
              },
              textPosition: 'in'
            }
          },
          geo: {
            colorAxis: {
              minValue: 0,
              colors: ['#aadff3', '#058dc7']
            }
          }
        };

        return merge({}, chartOptions.base, chartOptions[type]);
      }


      /**
       * Merge the source objects, in order, onto the destination object.
       * Recursively merge nested, plain objects, everything else copy by
       * reference.
       * @param {Object} target - The object to receive the merged values.
       * @param {...Object} source - The object(s) to provide values to the
       *  target. Later sources override previous sources.
       * @return {Object} The merged target object.
       */
      function merge(target) {
        var sources = [].slice.call(arguments, 1);
        sources.forEach(function(source) {
          Object.keys(source).forEach(function(key) {
            if (typeof source[key] == 'object' &&
                Object.getPrototypeOf(source[key]) == Object.prototype) {
              target[key] = target[key] == null ?
                  merge({}, source[key]) : merge(target[key], source[key]);
            }
            else if (typeof source[key] != 'undefined') {
              target[key] = source[key];
            }
          });
        });
        return target;
      }
    }());

  </script>

</polymer-element>
